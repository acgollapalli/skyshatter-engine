/*  SDG                          Kingdom Core: WASM                               JJ */

// @Incomplete(caleb): Just scaffolding for now.

// @Todo(caleb): create a decorator with a wasm_export and link prefix or something

#placeholder Wasm_Import_Table

Wasm_Exec_Flags :: enum_flags u8 {
	No_Exec :: 0x01; // control flow instructions still need to do stuff here
}

Wasm_Module :: struct {}

Wasm_Stack_State :: struct {
	index, stack_len, labels_len: int;
}

Wasm_Expression :: struct {}
// maybe we store the function on here?
Wasm_Stack_Frame :: struct { expr: Wasm_Expression; state: Wasm_Stack_State; }

Wasm_Ctx :: struct {
	flags: Wasm_Exec_Flags;
	using state: Wasm_Stack_State;
	//full_data: []u8;
	stack: []u8;                         // literally just some memory (no runtime typechecking)
	labels: []s64;                       // signed int because negative numbers mean something
	call_stack_len: int;                 // not_on_state because it doesn't get saved on the stack frame
	call_stack: []Wasm_Stack_Frame;      // added on each function call
	module: *Wasm_Module;                // Where all the code and data and such live
}

Wasm_Instruction_Handler :: (wasm_ctx: Wasm_Ctx) -> ok: bool, msg: string;

Wasm_Instruction_Flags :: enum_flags u8 {
	Has_Opcode :: 0x01;
	Has_Secondary :: 0x02;
}

// @Todo(caleb): write metaprogram to generate these
Wasm_Instruction_Signature :: struct {
	flags : Wasm_Instruction_Flags; // used for metadata generation
	instruction, opcode, secondary : u8;
	handler : Wasm_Instruction_Handler;
}

// generated by metaprogram
#placeholder Wasm_Instruction_LUT;

// @Todo(caleb): Type should be compile time constant
// @Todo(caleb): note that the bytecode is an array view
// but the full expression is stored in the code table of the wasm
// module
wasm_read_bytes :: (bytecode: []u8, type: Type) -> type {
	// if int type read leb128
	// if float type read IEEE float
	// if vec type read n of type
	// if string read string etc.
}

wasm_exec_next :: (bytecode: []u8, wasm_ctx: Wasm_Ctx) -> ok: bool, msg: string {
	i, j, k : u8;

	// @Todo(caleb): we probably need a way to handle bounds checks here
	// without crashing the program
	i =                                            wasm_read_bytes(bytecode, u8);
	j = ifx Wasm_Instruction_LUT[i].count > 1      wasm_read_bytes(bytecode, u8);
	k = ifx Wasm_Instruction_LUT[i][k].count > 1   wasm_read_bytes(bytecode, u8);

	// exec instruction
	return Wasm_Instruction_LUT[i][j][k].handler(wasm_ctx);
}

Wasm_Unreachable :: Wasm_Instruction_Signature.{ instruction = 0x00, handler = wasm_unreachable };
wasm_unreachable :: (wasm_ctx: Wasm_Ctx) -> ok: bool, msg: string {
	if wasm_ctx.flags & .No_Exec  return true;
	
	return false, "Reached the Unreachable Instruction. You assumed wrong, programmer."
}
